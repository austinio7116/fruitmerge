<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>Kawaii Fruit Merge (Local)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    
    <style>
        body {
            background-color: #FFF3E0;
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            margin: auto;
            width: 100%; 
            height: 100%;
            max-width: 450px; 
            max-height: 850px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 0 0 24px 24px;
            border-left: 16px solid #8D6E63;
            border-right: 16px solid #8D6E63;
            border-bottom: 16px solid #6D4C41;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }

        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop { animation: pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center overflow-hidden">
    
    <div class="absolute top-4 w-full max-w-[450px] px-6 flex justify-between items-start z-20 pointer-events-none">
        <div class="bg-white/90 backdrop-blur px-5 py-2 rounded-2xl shadow-lg border-2 border-amber-100 flex flex-col items-center">
            <span class="text-[10px] font-bold text-amber-800 uppercase tracking-widest">Score</span>
            <span class="text-3xl font-bold text-amber-500" id="score">0</span>
        </div>
        <div class="bg-white/90 backdrop-blur px-4 py-2 rounded-2xl shadow-lg border-2 border-amber-100 flex flex-col items-center">
            <span class="text-[10px] font-bold text-amber-800 uppercase tracking-widest mb-1">Next</span>
            <div class="w-10 h-10 flex items-center justify-center relative">
                <img class="w-full h-full object-contain drop-shadow-sm animate-float" id="next-fruit-img" style="clip-path: circle(50%); display: block;">
            </div>
        </div>
    </div>

    <div class="w-full h-full flex items-center justify-center p-2 sm:p-4">
        <div id="game-container">
            <canvas id="world" width="450" height="850"></canvas>
            
            <div class="absolute w-full border-t-2 border-dashed border-red-400 opacity-0 transition-opacity duration-300 pointer-events-none" id="danger-line" style="top: 130px; opacity: 0;">
                <span class="absolute right-2 -top-6 bg-red-400 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm">DANGER</span>
            </div>
            
            <div class="absolute top-[25%] w-full text-center pointer-events-none transition-opacity duration-500 opacity-0" id="hint" style="opacity: 0;">
                <span class="bg-black/20 text-white px-4 py-2 rounded-full text-sm font-bold backdrop-blur-sm">
                    Drag to Aim â€¢ Release to Drop
                </span>
            </div>
        </div>
    </div>

    <div class="absolute bottom-6 flex gap-4 z-20 pointer-events-auto">
        <button class="bg-white hover:bg-amber-50 text-amber-500 p-4 rounded-full shadow-xl border-2 border-amber-100 transition-transform active:scale-95 group" id="btn-reset">
            <span class="material-symbols-outlined group-hover:rotate-180 transition-transform duration-500">refresh</span>
        </button>
        <button class="bg-white hover:bg-amber-50 text-amber-500 p-4 rounded-full shadow-xl border-2 border-amber-100 transition-transform active:scale-95" id="btn-audio">
            <span class="material-symbols-outlined" id="icon-audio">volume_up</span>
        </button>
    </div>

    <div class="absolute inset-0 z-50 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4 hidden" id="modal-gameover">
        <div class="bg-white rounded-[2rem] p-8 max-w-sm w-full text-center shadow-2xl transform scale-100 animate-pop">
            <div class="text-6xl mb-4">ðŸ˜¿</div>
            <h2 class="text-3xl font-bold text-gray-800 mb-2">Oh no!</h2>
            <p class="text-gray-500 mb-6">The box is full.</p>
            <div class="bg-amber-50 p-4 rounded-2xl mb-6 border border-amber-100">
                <div class="text-xs uppercase font-bold text-amber-600 tracking-wider">Final Score</div>
                <div class="text-5xl font-bold text-amber-500 mt-1" id="final-score">0</div>
            </div>
            <button class="w-full bg-gradient-to-r from-amber-400 to-orange-500 hover:from-amber-500 hover:to-orange-600 text-white font-bold py-4 rounded-xl shadow-lg transition-all active:scale-95" id="btn-retry">
                Try Again
            </button>
        </div>
    </div>

    <script>
    (function() {
        const LOGICAL_WIDTH = 400;
        const LOGICAL_HEIGHT = 700;

        // Mapped from your local files (Smallest -> Largest)
        // 0: Cherry, 1: Strawberry, 2: Plum, 3: Orange, 4: Tomato, 
        // 5: Apple, 6: Pear, 7: Peach, 8: Pineapple, 9: Kiwi, 10: Watermelon
        const FRUIT_IMAGES = [
            "cherry.jpg",
            "strawberry.jpg",
            "plum.jpg",
            "orange.jpg",
            "tomato.jpg",
            "apple.jpg",
            "pear.jpg",
            "peach.jpg",
            "pineapple.jpg",
            "kiwi.jpg",
            "watermelon.jpg"
        ];

        const FRUITS = [
            { r: 16,  score: 0,    color: '#FF5252' }, // Cherry
            { r: 24,  score: 2,    color: '#FF4081' }, // Strawberry
            { r: 32,  score: 4,    color: '#E040FB' }, // Plum
            { r: 40,  score: 8,    color: '#FFAB40' }, // Orange
            { r: 48,  score: 16,   color: '#FF6E40' }, // Tomato
            { r: 58,  score: 32,   color: '#FF5252' }, // Apple
            { r: 68,  score: 64,   color: '#CDDC39' }, // Pear
            { r: 80,  score: 128,  color: '#F8BBD0' }, // Peach
            { r: 94,  score: 256,  color: '#FFEB3B' }, // Pineapple
            { r: 110, score: 512,  color: '#69F0AE' }, // Kiwi
            { r: 130, score: 1024, color: '#4CAF50' }  // Watermelon
        ];

        const Game = {
            engine: null,
            runner: null,
            canvas: null,
            ctx: null,
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            assets: [],
            score: 0,
            gameOver: false,
            isDropping: false,
            cooldown: false,
            dropper: { x: LOGICAL_WIDTH / 2, current: 0, next: 0 },
            audioEnabled: true,
            dangerTimer: 0,
            isDragging: false,
            floorBody: null,

            init: async function() {
                this.canvas = document.getElementById('world');
                this.ctx = this.canvas.getContext('2d');

                document.getElementById('btn-reset').onclick = () => this.reset();
                document.getElementById('btn-retry').onclick = () => this.reset();
                
                await this.loadImages();
                
                this.setupPhysics();
                this.setupInputs();
                this.setupAudio();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                requestAnimationFrame(() => this.loop());
                
                setTimeout(() => {
                    const hint = document.getElementById('hint');
                    hint.style.opacity = 1;
                    setTimeout(() => hint.style.opacity = 0, 3000);
                }, 500);

                this.reset();
            },

            loadImages: function() {
                return new Promise(resolve => {
                    let loaded = 0;
                    const total = FRUIT_IMAGES.length;
                    
                    for(let i=0; i<total; i++) {
                        const img = new Image();
                        img.onload = () => {
                            this.assets[i] = img;
                            loaded++;
                            if (loaded === total) resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load ${FRUIT_IMAGES[i]}`);
                            this.assets[i] = null; // Will fallback to colored circle
                            loaded++;
                            if (loaded === total) resolve();
                        };
                        img.src = FRUIT_IMAGES[i];
                    }
                });
            },

            setupPhysics: function() {
                const { Engine, World, Bodies, Runner, Events } = Matter;
                
                this.engine = Engine.create({
                    enableSleeping: true,
                    gravity: { x: 0, y: 1.2 },
                    positionIterations: 8,
                    velocityIterations: 8
                });

                const thickness = 200; 
                const wallOpts = { isStatic: true, friction: 0.5, restitution: 0.2, label: 'wall' };
                
                this.floorBody = Bodies.rectangle(LOGICAL_WIDTH/2, LOGICAL_HEIGHT + thickness/2, LOGICAL_WIDTH + 400, thickness, wallOpts);
                const leftWall = Bodies.rectangle(-thickness/2, LOGICAL_HEIGHT/2, thickness, LOGICAL_HEIGHT * 2, wallOpts);
                const rightWall = Bodies.rectangle(LOGICAL_WIDTH + thickness/2, LOGICAL_HEIGHT/2, thickness, LOGICAL_HEIGHT * 2, wallOpts);
                
                World.add(this.engine.world, [this.floorBody, leftWall, rightWall]);
                Events.on(this.engine, 'collisionStart', (e) => this.handleCollisions(e));

                this.runner = Runner.create();
                Runner.run(this.runner, this.engine);
            },

            resize: function() {
                const container = document.getElementById('game-container');
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                const scaleX = rect.width / LOGICAL_WIDTH;
                const scaleY = rect.height / LOGICAL_HEIGHT;
                this.scale = Math.min(scaleX, scaleY);
                
                this.offsetX = (rect.width - (LOGICAL_WIDTH * this.scale)) / 2;
                this.offsetY = (rect.height - (LOGICAL_HEIGHT * this.scale)) / 2;
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
            },

            setupInputs: function() {
                const container = document.getElementById('game-container');
                
                const getPhysicsX = (clientX) => {
                    const rect = container.getBoundingClientRect();
                    const screenX = clientX - rect.left;
                    let physX = (screenX - this.offsetX) / this.scale;
                    const r = FRUITS[this.dropper.current].r;
                    return Math.max(r, Math.min(physX, LOGICAL_WIDTH - r));
                };

                const handleStart = (x) => {
                    this.isDragging = true;
                    this.dropper.x = getPhysicsX(x);
                };
                const handleMove = (x) => {
                    this.dropper.x = getPhysicsX(x);
                };
                const handleEnd = () => {
                    if(this.isDragging) {
                        this.isDragging = false;
                        this.drop();
                    }
                };

                container.addEventListener('touchstart', (e) => {
                    if(e.target.tagName !== 'BUTTON') { e.preventDefault(); }
                    handleStart(e.touches[0].clientX);
                }, { passive: false });
                window.addEventListener('touchmove', (e) => {
                    if(this.isDragging) { e.preventDefault(); handleMove(e.touches[0].clientX); }
                }, { passive: false });
                window.addEventListener('touchend', () => handleEnd());

                container.addEventListener('mousedown', (e) => handleStart(e.clientX));
                window.addEventListener('mousemove', (e) => {
                    if(this.isDragging) handleMove(e.clientX);
                    else if(!this.gameOver) this.dropper.x = getPhysicsX(e.clientX);
                });
                window.addEventListener('mouseup', () => handleEnd());
            },

            setupAudio: async function() {
                await Tone.start();
                this.synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }
                }).toDestination();
                this.synth.volume.value = -12;
                document.getElementById('btn-audio').addEventListener('click', () => {
                    this.audioEnabled = !this.audioEnabled;
                    document.getElementById('icon-audio').innerText = this.audioEnabled ? 'volume_up' : 'volume_off';
                });
            },

            createFruitBody: function(x, y, type, isDynamic = true) {
                const { Bodies } = Matter;
                const radius = FRUITS[type].r;
                return Bodies.circle(x, y, radius, {
                    label: 'fruit',
                    fruitType: type,
                    isStatic: !isDynamic,
                    restitution: 0.2,
                    friction: 0.5,
                    density: 0.002,
                    frictionAir: 0.02,
                    angularDamping: 0.6,
                    slop: 0.05
                });
            },

            handleCollisions: function(event) {
                const { World } = Matter;
                const processed = new Set();
                
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label === 'fruit' && bodyB.label === 'fruit') {
                        if (bodyA.fruitType === bodyB.fruitType && bodyA.fruitType < FRUITS.length - 1) {
                            if (processed.has(bodyA.id) || processed.has(bodyB.id)) return;
                            processed.add(bodyA.id);
                            processed.add(bodyB.id);

                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            const newType = bodyA.fruitType + 1;

                            World.remove(this.engine.world, [bodyA, bodyB]);
                            const newBody = this.createFruitBody(midX, midY, newType);
                            Matter.Body.setVelocity(newBody, { x: (Math.random()-0.5), y: -1 });
                            World.add(this.engine.world, newBody);

                            this.score += FRUITS[newType].score;
                            document.getElementById('score').innerText = this.score;
                            
                            if(this.audioEnabled) {
                                const scale = ["C4", "E4", "G4", "B4", "C5", "E5", "G5"];
                                this.synth.triggerAttackRelease(scale[newType % scale.length], "16n");
                            }
                        }
                    }
                });
            },

            drop: function() {
                if(this.isDropping || this.cooldown || this.gameOver) return;
                if(this.audioEnabled && Tone.context.state !== 'running') Tone.start();

                this.isDropping = true;
                this.cooldown = true;

                const body = this.createFruitBody(this.dropper.x, 50, this.dropper.current);
                Matter.World.add(this.engine.world, body);

                setTimeout(() => {
                    this.isDropping = false;
                    this.cooldown = false;
                    this.dropper.current = this.dropper.next;
                    this.dropper.next = Math.floor(Math.random() * 5);
                    this.updateNextUI();
                }, 600);
            },

            reset: function() {
                Matter.Composite.clear(this.engine.world, true); 
                
                this.score = 0;
                document.getElementById('score').innerText = 0;
                this.gameOver = false;
                this.dropper.current = 0;
                this.dropper.next = 0;
                this.updateNextUI();
                
                document.getElementById('modal-gameover').classList.add('hidden');
                document.getElementById('danger-line').style.opacity = 0;
            },

            updateNextUI: function() {
                const img = document.getElementById('next-fruit-img');
                const asset = this.assets[this.dropper.next];
                img.src = asset ? asset.src : "";
                img.style.display = asset ? 'block' : 'none';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            },

            update: function() {
                if(this.gameOver) return;
                
                const bodies = Matter.Composite.allBodies(this.engine.world);
                let danger = false;
                const dangerY = 120;
                
                bodies.forEach(b => {
                    if(b.label === 'fruit' && b.position.y < dangerY && b.speed < 0.2 && !this.isDropping) {
                        danger = true;
                    }
                });
                
                const line = document.getElementById('danger-line');
                if(danger) {
                    line.style.opacity = 1;
                    this.dangerTimer += 16;
                    if(this.dangerTimer > 2000) {
                        this.gameOver = true;
                        document.getElementById('final-score').innerText = this.score;
                        document.getElementById('modal-gameover').classList.remove('hidden');
                    }
                } else {
                    line.style.opacity = 0;
                    this.dangerTimer = 0;
                }
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);

                // Dropper Line
                if(!this.gameOver) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.dropper.x, 30);
                    this.ctx.lineTo(this.dropper.x, LOGICAL_HEIGHT);
                    this.ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // Ghost
                if(!this.isDropping && !this.gameOver) {
                    const r = FRUITS[this.dropper.current].r;
                    const visualR = r * 1.05;
                    const asset = this.assets[this.dropper.current];
                    this.ctx.globalAlpha = 0.6;
                    this.drawSprite(this.dropper.x, 30, visualR, 0, FRUITS[this.dropper.current].color, asset);
                    this.ctx.globalAlpha = 1.0;
                }

                // Fruits
                const bodies = Matter.Composite.allBodies(this.engine.world);
                bodies.forEach(b => {
                    if(b.label === 'fruit') {
                        const r = FRUITS[b.fruitType].r;
                        const visualR = r * 1.05;
                        const asset = this.assets[b.fruitType];
                        this.drawSprite(b.position.x, b.position.y, visualR, b.angle, FRUITS[b.fruitType].color, asset);
                    }
                });

                this.ctx.restore();
            },

            drawSprite: function(x, y, radius, angle, color, asset) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);
                
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius, 0, Math.PI*2);
                this.ctx.clip();

                // Draw background color (behind the image or as fallback)
                this.ctx.fillStyle = color;
                this.ctx.fill();

                if(asset && asset.complete && asset.naturalHeight !== 0) {
                    this.ctx.drawImage(asset, -radius, -radius, radius*2, radius*2);
                }
                
                this.ctx.lineWidth = 1.5;
                this.ctx.strokeStyle = "rgba(0,0,0,0.05)";
                this.ctx.stroke();
                this.ctx.restore();
            }
        };

        window.onload = () => Game.init();
    })();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#FFF3E0">
    <title>Kawaii Fruit Merge</title>
    
    <link rel="manifest" href="manifest.json">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    
    <style>
        body {
            background-color: #FFF3E0;
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            margin: auto;
            width: 100%; 
            height: 100%;
            max-width: 450px; 
            max-height: 850px;
            background: rgba(255, 255, 255, 0.5);
            /* Visual borders */
            border-left: 16px solid #8D6E63;
            border-right: 16px solid #8D6E63;
            border-bottom: 16px solid #6D4C41;
            border-radius: 0 0 24px 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Ensure canvas fills container exactly */
            object-fit: contain; 
        }

        /* UI Animations */
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }

        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop { animation: pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        .menu-btn {
            background: white;
            border: 2px solid #FEF3C7;
            color: #F59E0B;
            border-radius: 50%;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }
        .menu-btn:active { transform: scale(0.9); }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center overflow-hidden">
    
    <div class="absolute top-2 w-full max-w-[500px] px-4 flex justify-between items-start z-30 pointer-events-none">
        
        <div class="pointer-events-auto relative">
            <button id="btn-menu" class="menu-btn w-12 h-12 flex items-center justify-center">
                <span class="material-symbols-outlined">settings</span>
            </button>
            
            <div id="menu-dropdown" class="absolute top-14 left-0 bg-white/95 backdrop-blur rounded-2xl p-3 shadow-xl border-2 border-amber-100 flex flex-col gap-3 transition-all duration-200 opacity-0 scale-95 pointer-events-none origin-top-left">
                <button id="btn-audio" class="flex items-center gap-3 px-3 py-2 rounded-xl hover:bg-amber-50 text-amber-600 font-bold whitespace-nowrap">
                    <span class="material-symbols-outlined" id="icon-audio">volume_up</span>
                    <span>Sound</span>
                </button>
                <button id="btn-reset" class="flex items-center gap-3 px-3 py-2 rounded-xl hover:bg-amber-50 text-amber-600 font-bold whitespace-nowrap">
                    <span class="material-symbols-outlined">refresh</span>
                    <span>Reset Game</span>
                </button>
            </div>
        </div>

        <div class="flex gap-2">
            <div class="bg-white/90 backdrop-blur px-4 py-2 rounded-2xl shadow-md border-2 border-amber-100 flex flex-col items-center min-w-[80px]">
                <span class="text-[9px] font-bold text-amber-800 uppercase tracking-widest">Score</span>
                <span class="text-2xl font-bold text-amber-500" id="score">0</span>
            </div>
            
            <div class="bg-white/90 backdrop-blur px-3 py-2 rounded-2xl shadow-md border-2 border-amber-100 flex flex-col items-center">
                <span class="text-[9px] font-bold text-amber-800 uppercase tracking-widest mb-1">Next</span>
                <div class="w-7 h-7 flex items-center justify-center relative">
                    <img class="w-full h-full object-contain drop-shadow-sm animate-float" id="next-fruit-img" style="clip-path: circle(50%); display: block;">
                </div>
            </div>
        </div>

        <button id="btn-fullscreen" class="menu-btn w-12 h-12 flex items-center justify-center pointer-events-auto">
            <span class="material-symbols-outlined" id="icon-fullscreen">fullscreen</span>
        </button>
    </div>

    <div class="w-full h-full flex items-center justify-center p-0 sm:p-4">
        <div id="game-container">
            <canvas id="world" width="450" height="850"></canvas>
            
            <div class="absolute w-full border-t-2 border-dashed border-red-400 opacity-0 transition-opacity duration-300 pointer-events-none" id="danger-line" style="top: 130px; opacity: 0;">
                <span class="absolute right-2 -top-6 bg-red-400 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm">DANGER</span>
            </div>
            
            <div class="absolute top-[30%] w-full text-center pointer-events-none transition-opacity duration-500 opacity-0" id="hint">
                <span class="bg-black/20 text-white px-4 py-2 rounded-full text-sm font-bold backdrop-blur-sm">
                    Drag to Aim â€¢ Release to Drop
                </span>
            </div>
        </div>
    </div>

    <div class="absolute inset-0 z-50 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4 hidden" id="modal-gameover">
        <div class="bg-white rounded-[2rem] p-8 max-w-sm w-full text-center shadow-2xl transform scale-100 animate-pop">
            <div class="text-6xl mb-4">ðŸ˜¿</div>
            <h2 class="text-3xl font-bold text-gray-800 mb-2">Oh no!</h2>
            <p class="text-gray-500 mb-6">The box is full.</p>
            <div class="bg-amber-50 p-4 rounded-2xl mb-6 border border-amber-100">
                <div class="text-xs uppercase font-bold text-amber-600 tracking-wider">Final Score</div>
                <div class="text-5xl font-bold text-amber-500 mt-1" id="final-score">0</div>
            </div>
            <button class="w-full bg-gradient-to-r from-amber-400 to-orange-500 hover:from-amber-500 hover:to-orange-600 text-white font-bold py-4 rounded-xl shadow-lg transition-all active:scale-95" id="btn-retry">
                Try Again
            </button>
        </div>
    </div>

    <script>
    (function() {
        // MATCH LOGICAL DIMENSIONS TO CANVAS DIMENSIONS EXACTLY
        // This ensures the physics floor matches the visual floor
        const LOGICAL_WIDTH = 450; 
        const LOGICAL_HEIGHT = 850;

        const FRUIT_IMAGES = [
            "cherry.jpg", "strawberry.jpg", "plum.jpg", "orange.jpg", "tomato.jpg", 
            "apple.jpg", "pear.jpg", "peach.jpg", "pineapple.jpg", "kiwi.jpg", "watermelon.jpg"
        ];

        const FRUITS = [
            { r: 16,  score: 0,    color: '#FF5252' }, 
            { r: 24,  score: 2,    color: '#FF4081' }, 
            { r: 32,  score: 4,    color: '#E040FB' }, 
            { r: 40,  score: 8,    color: '#FFAB40' }, 
            { r: 48,  score: 16,   color: '#FF6E40' }, 
            { r: 58,  score: 32,   color: '#FF5252' }, 
            { r: 68,  score: 64,   color: '#CDDC39' }, 
            { r: 80,  score: 128,  color: '#F8BBD0' }, 
            { r: 94,  score: 256,  color: '#FFEB3B' }, 
            { r: 110, score: 512,  color: '#69F0AE' }, 
            { r: 130, score: 1024, color: '#4CAF50' }  
        ];

        const Game = {
            engine: null, runner: null, canvas: null, ctx: null,
            scale: 1, offsetX: 0, offsetY: 0,
            assets: [], score: 0, gameOver: false, isDropping: false, cooldown: false,
            dropper: { x: LOGICAL_WIDTH / 2, current: 0, next: 0 },
            audioEnabled: true, dangerTimer: 0, isDragging: false, menuOpen: false,

            init: async function() {
                this.canvas = document.getElementById('world');
                this.ctx = this.canvas.getContext('2d');

                // UI Event Listeners
                document.getElementById('btn-reset').onclick = () => { this.reset(); this.toggleMenu(false); };
                document.getElementById('btn-retry').onclick = () => this.reset();
                document.getElementById('btn-menu').onclick = () => this.toggleMenu();
                document.getElementById('btn-fullscreen').onclick = () => this.toggleFullscreen();
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#btn-menu') && !e.target.closest('#menu-dropdown')) {
                        this.toggleMenu(false);
                    }
                });

                await this.loadImages();
                this.setupPhysics();
                this.setupInputs();
                this.setupAudio();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                requestAnimationFrame(() => this.loop());
                
                setTimeout(() => {
                    const hint = document.getElementById('hint');
                    hint.style.opacity = 1;
                    setTimeout(() => hint.style.opacity = 0, 3000);
                }, 500);

                this.reset();
            },

            toggleMenu: function(forceState) {
                const menu = document.getElementById('menu-dropdown');
                if (typeof forceState !== 'undefined') this.menuOpen = forceState;
                else this.menuOpen = !this.menuOpen;

                if (this.menuOpen) {
                    menu.classList.remove('opacity-0', 'scale-95', 'pointer-events-none');
                } else {
                    menu.classList.add('opacity-0', 'scale-95', 'pointer-events-none');
                }
            },

            toggleFullscreen: function() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch((err) => {
                        console.log(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            },

            loadImages: function() {
                return new Promise(resolve => {
                    let loaded = 0;
                    const total = FRUIT_IMAGES.length;
                    for(let i=0; i<total; i++) {
                        const img = new Image();
                        img.onload = () => { this.assets[i] = img; loaded++; if (loaded === total) resolve(); };
                        img.onerror = () => { this.assets[i] = null; loaded++; if (loaded === total) resolve(); };
                        img.src = FRUIT_IMAGES[i];
                    }
                });
            },

            setupPhysics: function() {
                const { Engine, World, Bodies, Runner, Events } = Matter;
                this.engine = Engine.create({
                    enableSleeping: true,
                    gravity: { x: 0, y: 1.5 }, // Slightly heavier gravity for better feel
                });

                const thickness = 100; 
                // Wall Options
                const wallOpts = { isStatic: true, friction: 0.8, restitution: 0.1, label: 'wall' };
                
                // FLOOR: Positioned so the top edge is exactly at LOGICAL_HEIGHT
                // y = LOGICAL_HEIGHT + (thickness / 2)
                const floor = Bodies.rectangle(LOGICAL_WIDTH/2, LOGICAL_HEIGHT + thickness/2, LOGICAL_WIDTH + 200, thickness, wallOpts);
                
                const leftWall = Bodies.rectangle(-thickness/2, LOGICAL_HEIGHT/2, thickness, LOGICAL_HEIGHT * 2, wallOpts);
                const rightWall = Bodies.rectangle(LOGICAL_WIDTH + thickness/2, LOGICAL_HEIGHT/2, thickness, LOGICAL_HEIGHT * 2, wallOpts);
                
                World.add(this.engine.world, [floor, leftWall, rightWall]);
                Events.on(this.engine, 'collisionStart', (e) => this.handleCollisions(e));

                this.runner = Runner.create();
                Runner.run(this.runner, this.engine);
            },

            resize: function() {
                const container = document.getElementById('game-container');
                
                // FIX 1: Use clientWidth/Height to get the inner size (inside the borders)
                // This ensures the canvas matches the white area exactly.
                const width = container.clientWidth;
                const height = container.clientHeight;
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                
                // Calculate scale to fit the logical dimensions
                const scaleX = width / LOGICAL_WIDTH;
                const scaleY = height / LOGICAL_HEIGHT;
                this.scale = Math.min(scaleX, scaleY);
                
                // Align horizontally center
                this.offsetX = (width - (LOGICAL_WIDTH * this.scale)) / 2;
                
                // FIX 2: Align vertically to the BOTTOM
                // Instead of centering ((height - logical)/2), we push it to the bottom.
                // This removes the gap between the fruit and the floor on tall screens.
                this.offsetY = height - (LOGICAL_HEIGHT * this.scale);
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
            },

            setupInputs: function() {
                const container = document.getElementById('game-container');
                const getPhysicsX = (clientX) => {
                    const rect = container.getBoundingClientRect();
                    const screenX = clientX - rect.left;
                    let physX = (screenX - this.offsetX) / this.scale;
                    const r = FRUITS[this.dropper.current].r;
                    return Math.max(r, Math.min(physX, LOGICAL_WIDTH - r));
                };

                const handleStart = (x) => {
                    if(this.menuOpen) return;
                    this.isDragging = true;
                    this.dropper.x = getPhysicsX(x);
                };
                
                const handleMove = (x) => {
                    this.dropper.x = getPhysicsX(x);
                };
                
                const handleEnd = () => {
                    if(this.isDragging) {
                        this.isDragging = false;
                        this.drop();
                    }
                };

                // Touch
                container.addEventListener('touchstart', (e) => {
                    if(e.target.tagName !== 'BUTTON' && !this.menuOpen) { e.preventDefault(); }
                    handleStart(e.touches[0].clientX);
                }, { passive: false });
                window.addEventListener('touchmove', (e) => {
                    if(this.isDragging) { e.preventDefault(); handleMove(e.touches[0].clientX); }
                }, { passive: false });
                window.addEventListener('touchend', () => handleEnd());

                // Mouse
                container.addEventListener('mousedown', (e) => handleStart(e.clientX));
                window.addEventListener('mousemove', (e) => {
                    if(this.isDragging) handleMove(e.clientX);
                    else if(!this.gameOver && !this.menuOpen) this.dropper.x = getPhysicsX(e.clientX);
                });
                window.addEventListener('mouseup', () => handleEnd());
            },

            setupAudio: async function() {
                await Tone.start();
                this.synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }
                }).toDestination();
                this.synth.volume.value = -12;
                document.getElementById('btn-audio').addEventListener('click', () => {
                    this.audioEnabled = !this.audioEnabled;
                    document.getElementById('icon-audio').innerText = this.audioEnabled ? 'volume_up' : 'volume_off';
                });
            },

            createFruitBody: function(x, y, type, isDynamic = true) {
                const { Bodies } = Matter;
                const radius = FRUITS[type].r;
                return Bodies.circle(x, y, radius, {
                    label: 'fruit',
                    fruitType: type,
                    isStatic: !isDynamic,
                    restitution: 0.2,
                    friction: 0.5,
                    density: 0.002,
                });
            },

            handleCollisions: function(event) {
                const { World } = Matter;
                const processed = new Set();
                
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label === 'fruit' && bodyB.label === 'fruit') {
                        if (bodyA.fruitType === bodyB.fruitType && bodyA.fruitType < FRUITS.length - 1) {
                            if (processed.has(bodyA.id) || processed.has(bodyB.id)) return;
                            processed.add(bodyA.id);
                            processed.add(bodyB.id);

                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            const newType = bodyA.fruitType + 1;

                            World.remove(this.engine.world, [bodyA, bodyB]);
                            const newBody = this.createFruitBody(midX, midY, newType);
                            World.add(this.engine.world, newBody);

                            this.score += FRUITS[newType].score;
                            document.getElementById('score').innerText = this.score;
                            
                            if(this.audioEnabled) {
                                const scale = ["C4", "E4", "G4", "B4", "C5", "E5", "G5"];
                                this.synth.triggerAttackRelease(scale[newType % scale.length], "16n");
                            }
                        }
                    }
                });
            },

            drop: function() {
                if(this.isDropping || this.cooldown || this.gameOver || this.menuOpen) return;
                if(this.audioEnabled && Tone.context.state !== 'running') Tone.start();

                this.isDropping = true;
                this.cooldown = true;

                const body = this.createFruitBody(this.dropper.x, 50, this.dropper.current);
                Matter.World.add(this.engine.world, body);

                setTimeout(() => {
                    this.isDropping = false;
                    this.cooldown = false;
                    this.dropper.current = this.dropper.next;
                    this.dropper.next = Math.floor(Math.random() * 5);
                    this.updateNextUI();
                }, 600);
            },

             reset: function() {
                // Fix: Change 'false' to 'true' to keep static bodies (walls/floor)
                Matter.Composite.clear(this.engine.world, true); 
                
                // Double check: manually remove any remaining 'fruit' bodies just in case
                const bodies = Matter.Composite.allBodies(this.engine.world);
                bodies.forEach(b => {
                    if(b.label === 'fruit') Matter.World.remove(this.engine.world, b);
                });

                this.score = 0;
                document.getElementById('score').innerText = 0;
                this.gameOver = false;
                this.dropper.current = 0;
                this.dropper.next = 0;
                this.updateNextUI();
                
                document.getElementById('modal-gameover').classList.add('hidden');
                document.getElementById('danger-line').style.opacity = 0;
            },

            updateNextUI: function() {
                const img = document.getElementById('next-fruit-img');
                const asset = this.assets[this.dropper.next];
                img.src = asset ? asset.src : "";
                img.style.display = asset ? 'block' : 'none';
            },

            loop: function() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            },

            update: function() {
                if(this.gameOver) return;
                
                const bodies = Matter.Composite.allBodies(this.engine.world);
                let danger = false;
                const dangerY = 120;
                
                bodies.forEach(b => {
                    if(b.label === 'fruit' && b.position.y < dangerY && b.speed < 0.2 && !this.isDropping) {
                        danger = true;
                    }
                });
                
                const line = document.getElementById('danger-line');
                if(danger) {
                    line.style.opacity = 1;
                    this.dangerTimer += 16;
                    if(this.dangerTimer > 2000) {
                        this.gameOver = true;
                        document.getElementById('final-score').innerText = this.score;
                        document.getElementById('modal-gameover').classList.remove('hidden');
                    }
                } else {
                    line.style.opacity = 0;
                    this.dangerTimer = 0;
                }
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);

                // Guide Line
                if(!this.gameOver && !this.menuOpen) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.dropper.x, 30);
                    this.ctx.lineTo(this.dropper.x, LOGICAL_HEIGHT);
                    this.ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                
                    // Ghost Fruit
                    if(!this.isDropping) {
                        const r = FRUITS[this.dropper.current].r;
                        const asset = this.assets[this.dropper.current];
                        this.ctx.globalAlpha = 0.6;
                        this.drawSprite(this.dropper.x, 30, r, 0, FRUITS[this.dropper.current].color, asset);
                        this.ctx.globalAlpha = 1.0;
                    }
                }

                // Render Bodies
                const bodies = Matter.Composite.allBodies(this.engine.world);
                bodies.forEach(b => {
                    if(b.label === 'fruit') {
                        const r = FRUITS[b.fruitType].r;
                        const asset = this.assets[b.fruitType];
                        this.drawSprite(b.position.x, b.position.y, r, b.angle, FRUITS[b.fruitType].color, asset);
                    }
                });

                this.ctx.restore();
            },

            drawSprite: function(x, y, radius, angle, color, asset) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);
                
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius, 0, Math.PI*2);
                this.ctx.clip();

                this.ctx.fillStyle = color;
                this.ctx.fill();

                if(asset && asset.complete && asset.naturalHeight !== 0) {
                    this.ctx.drawImage(asset, -radius, -radius, radius*2, radius*2);
                }
                
                this.ctx.lineWidth = 1.5;
                this.ctx.strokeStyle = "rgba(0,0,0,0.05)";
                this.ctx.stroke();
                this.ctx.restore();
            }
        };

        window.onload = () => Game.init();
    })();
    </script>
</body>
</html>
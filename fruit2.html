<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Merge Fruit Drop+</title>
  <style>
    html, body { margin:0; height:100%; background:#0f1220; overflow:hidden; touch-action:none; }
    #wrap { position:relative; width:100%; height:100%; }

    canvas { display:block; width:100%; height:100%; }

    .hud {
      position:absolute; left:12px; top:12px; z-index:10;
      color:#e9ecff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:rgba(0,0,0,.35); backdrop-filter: blur(8px);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius:12px;
      user-select:none;
      display:flex; gap:12px; align-items:center;
      flex-wrap:wrap;
    }
    .hud b { font-weight:700; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill {
      padding:6px 10px; border-radius:999px;
      background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12);
    }
    .btn {
      display:inline-block; padding:6px 10px; border-radius:10px;
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.12);
      color:#e9ecff; cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }

    .queue { display:flex; gap:8px; align-items:center; }
    .qimg {
      width:34px; height:34px; border-radius:10px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    .qimg img { width:100%; height:100%; object-fit:cover; }

    .hint {
      position:absolute; left:12px; bottom:12px; z-index:10;
      color:#cbd1ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.10);
      padding:10px 12px; border-radius:12px;
      max-width:min(560px, calc(100vw - 24px));
      user-select:none;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div class="row pill"><b>Score:</b>&nbsp;<span id="score">0</span></div>

    <div class="row pill">
      <b>Next:</b>&nbsp;
      <div class="queue" id="queue"></div>
    </div>

    <div class="row">
      <span class="btn" id="restart">Restart</span>
      <span class="btn" id="mute">Sound: On</span>
    </div>
  </div>

  <div class="hint">
    Drag left/right then release to drop. Same fruit + same fruit = bigger fruit.
    The dashed line shows the landing spot. Donâ€™t overflow the box!
  </div>

  <canvas id="c"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
(() => {
  const {
    Engine, Render, Runner, World, Bodies, Body, Events, Composite, Query, Vector
  } = Matter;

  const canvas = document.getElementById('c');
  const wrap = document.getElementById('wrap');

  const scoreEl = document.getElementById('score');
  const queueEl = document.getElementById('queue');
  const restartBtn = document.getElementById('restart');
  const muteBtn = document.getElementById('mute');

  // ---------- Responsive canvas ----------
  let W = 0, H = 0;

  const engine = Engine.create();
  engine.gravity.y = 1.05;

  const render = Render.create({
    canvas,
    engine,
    options: {
      width: 800, height: 600,
      wireframes: false,
      background: '#0f1220',
      pixelRatio: window.devicePixelRatio || 1
    }
  });

  const runner = Runner.create();

  // ---------- Fruit defs ----------
  const FRUITS = [
    { name: 'Cherry',      r: 16,  hue: 350, sides: 0 },  // circle
    { name: 'Grape',       r: 22,  hue: 285, sides: 0 },  // circle
    { name: 'Orange',      r: 30,  hue:  30, sides: 10 },
    { name: 'Apple',       r: 38,  hue: 110, sides: 12 },
    { name: 'Peach',       r: 48,  hue:  10, sides: 9  },
    { name: 'Melon',       r: 62,  hue: 160, sides: 14 },
    { name: 'Pumpkin',     r: 78,  hue:  45, sides: 11 },
    { name: 'Watermelon',  r: 96,  hue: 140, sides: 16 }
  ];

  const DROP_MAX_INDEX = 4;       // up to Peach
  const MERGE_COOLDOWN_MS = 150;

  // ---------- Cute fruit textures (procedural) ----------
  const textures = new Map();

  function makeFruitTexture(def) {
    const dpr = window.devicePixelRatio || 1;
    const pad = Math.ceil(def.r * 0.42);
    const size = Math.ceil((def.r * 2 + pad * 2) * dpr);

    const oc = document.createElement('canvas');
    oc.width = size;
    oc.height = size;
    const ctx = oc.getContext('2d');

    ctx.scale(dpr, dpr);
    const S = def.r * 2 + pad * 2;
    const cx = S / 2;
    const cy = S / 2;

    // body gradient
    const base = `hsl(${def.hue} 85% 55%)`;
    const light = `hsl(${def.hue} 92% 70%)`;
    const dark  = `hsl(${def.hue} 75% 40%)`;

    const g = ctx.createRadialGradient(cx - def.r*0.35, cy - def.r*0.45, def.r*0.15, cx, cy, def.r*1.35);
    g.addColorStop(0, light);
    g.addColorStop(0.55, base);
    g.addColorStop(1, dark);

    // fruit body
    ctx.beginPath();
    ctx.arc(cx, cy, def.r, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();

    // subtle rim
    ctx.beginPath();
    ctx.arc(cx, cy, def.r*0.985, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = Math.max(1.5, def.r*0.06);
    ctx.stroke();

    // highlight blob
    ctx.save();
    ctx.translate(cx - def.r*0.28, cy - def.r*0.42);
    ctx.rotate(-0.35);
    ctx.beginPath();
    ctx.ellipse(0, 0, def.r*0.48, def.r*0.34, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.26)';
    ctx.fill();
    ctx.restore();

    // cute face: big eyes with reflections
    const eyeY = cy + def.r*0.10;
    const eyeXOff = def.r*0.34;
    const eyeR = def.r*0.23;
    const pupilR = def.r*0.12;

    function drawEye(ex) {
      ctx.beginPath();
      ctx.arc(ex, eyeY, eyeR, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.96)';
      ctx.fill();

      const eg = ctx.createRadialGradient(ex, eyeY + eyeR*0.35, eyeR*0.12, ex, eyeY, eyeR);
      eg.addColorStop(0, 'rgba(0,0,0,0.10)');
      eg.addColorStop(1, 'rgba(0,0,0,0.00)');
      ctx.beginPath();
      ctx.arc(ex, eyeY, eyeR, 0, Math.PI*2);
      ctx.fillStyle = eg;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(ex + eyeR*0.10, eyeY + eyeR*0.12, pupilR, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(20,22,35,0.95)';
      ctx.fill();

      // reflections
      ctx.beginPath();
      ctx.arc(ex + eyeR*0.25, eyeY - eyeR*0.22, pupilR*0.35, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(ex + eyeR*0.05, eyeY - eyeR*0.35, pupilR*0.20, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(ex, eyeY, eyeR, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = Math.max(1, def.r*0.03);
      ctx.stroke();
    }

    drawEye(cx - eyeXOff);
    drawEye(cx + eyeXOff);

    // smile
    ctx.beginPath();
    const smileY = cy + def.r*0.40;
    ctx.arc(cx, smileY, def.r*0.28, 0.14*Math.PI, 0.86*Math.PI, false);
    ctx.strokeStyle = 'rgba(50,20,25,0.55)';
    ctx.lineWidth = Math.max(1.6, def.r*0.05);
    ctx.lineCap = 'round';
    ctx.stroke();

    // blush
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = `hsl(${def.hue} 95% 78%)`;
    ctx.beginPath();
    ctx.arc(cx - def.r*0.56, cy + def.r*0.30, def.r*0.14, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + def.r*0.56, cy + def.r*0.30, def.r*0.14, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    return oc;
  }

  function ensureTextures() {
    textures.clear();
    for (const f of FRUITS) textures.set(f.name, makeFruitTexture(f));
  }

  // ---------- Box walls (less wide, centered) ----------
  let walls = [];
  const WALL_THICK = 40;
  let boxLeft = 0, boxRight = 0, boxBottom = 0, boxTop = 0;

  function rebuildWalls() {
    for (const w of walls) Composite.remove(engine.world, w);
    walls = [];

    const marginBottom = Math.max(16, Math.min(28, W * 0.03));
    boxBottom = H - marginBottom;
    boxTop = Math.max(120, H * 0.14);

    // Make the box narrower than the screen (and still responsive).
    const boxWidth = Math.min(Math.max(320, W * 0.70), 520);
    boxLeft  = (W - boxWidth) / 2;
    boxRight = boxLeft + boxWidth;

    const floor = Bodies.rectangle(W/2, boxBottom + WALL_THICK/2, boxWidth + WALL_THICK*2, WALL_THICK, {
      isStatic:true, render:{ fillStyle:'rgba(255,255,255,0.10)' }
    });
    const left = Bodies.rectangle(boxLeft - WALL_THICK/2, (boxTop+boxBottom)/2, WALL_THICK, (boxBottom-boxTop) + WALL_THICK, {
      isStatic:true, render:{ fillStyle:'rgba(255,255,255,0.08)' }
    });
    const right = Bodies.rectangle(boxRight + WALL_THICK/2, (boxTop+boxBottom)/2, WALL_THICK, (boxBottom-boxTop) + WALL_THICK, {
      isStatic:true, render:{ fillStyle:'rgba(255,255,255,0.08)' }
    });

    // Top lip line (sensor only, used visually + overflow check reference)
    const lip = Bodies.rectangle(W/2, boxTop, boxWidth, 2, {
      isStatic:true, isSensor:true, render:{ fillStyle:'rgba(255,255,255,0.18)' }
    });

    walls.push(floor, left, right, lip);
    World.add(engine.world, walls);
  }

  function resize() {
    W = wrap.clientWidth;
    H = wrap.clientHeight;

    render.options.width = W;
    render.options.height = H;

    const dpr = window.devicePixelRatio || 1;
    render.canvas.width = Math.floor(W * dpr);
    render.canvas.height = Math.floor(H * dpr);
    render.canvas.style.width = W + 'px';
    render.canvas.style.height = H + 'px';

    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: W, y: H } });
    rebuildWalls();
    updateQueueUI();
  }

  window.addEventListener('resize', resize, { passive:true });

  // ---------- Sound (WebAudio, tiny synth) ----------
  let audioCtx = null;
  let muted = false;

  function ensureAudio() {
    if (muted) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  }

  function playTone(freq, dur = 0.08, type = 'sine', gain = 0.06) {
    if (muted) return;
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur + 0.02);
  }

  function sfxDrop() {
    playTone(140, 0.08, 'triangle', 0.05);
    playTone(90,  0.10, 'sine',     0.04);
  }
  function sfxMerge() {
    playTone(520, 0.07, 'sine',     0.06);
    playTone(820, 0.05, 'triangle', 0.04);
  }

  muteBtn.addEventListener('click', () => {
    muted = !muted;
    muteBtn.textContent = muted ? 'Sound: Off' : 'Sound: On';
    if (!muted) ensureAudio();
  });

  // ---------- Game state ----------
  let score = 0;

  // queue of next fruits (show next 3)
  const QUEUE_LEN = 3;
  let nextQueue = [];

  let heldFruit = null;
  let isDragging = false;
  let pointerId = null;
  let lastMergeAt = 0;

  // merge-lock to avoid double-processing
  const mergeLock = new Set();

  // pop animations
  const pops = []; // {x,y,t0,size}
  function addPop(x,y,size) {
    pops.push({ x, y, t0: performance.now(), size });
    if (pops.length > 60) pops.splice(0, pops.length - 60);
  }

  function setScore(v) {
    score = v;
    scoreEl.textContent = String(score);
  }

  function randNextIndex() {
    // weighted toward smaller fruits
    const roll = Math.random();
    let idx;
    if (roll < 0.55) idx = 0;
    else if (roll < 0.80) idx = 1;
    else if (roll < 0.92) idx = 2;
    else idx = Math.min(DROP_MAX_INDEX, 3);
    return idx;
  }

  function initQueue() {
    nextQueue = [];
    for (let i = 0; i < QUEUE_LEN; i++) nextQueue.push(randNextIndex());
    updateQueueUI();
  }

  function updateQueueUI() {
    if (!queueEl) return;
    queueEl.innerHTML = '';
    for (let i = 0; i < nextQueue.length; i++) {
      const idx = nextQueue[i];
      const def = FRUITS[idx];
      const tex = textures.get(def.name);

      const slot = document.createElement('div');
      slot.className = 'qimg';

      const img = document.createElement('img');
      img.alt = def.name;
      img.src = tex.toDataURL();
      slot.title = def.name;

      slot.appendChild(img);
      queueEl.appendChild(slot);
    }
  }

  function nextFruitIndex() {
    return nextQueue[0];
  }

  function consumeNextFruit() {
    nextQueue.shift();
    nextQueue.push(randNextIndex());
    updateQueueUI();
  }

function fruitBody(index, x, y, options = {}) {
    const def = FRUITS[index];
    const tex = textures.get(def.name);
    const now = performance.now();

    const baseOpts = {
        restitution: 0.02,
        friction: 0.18,
        frictionAir: 0.012,
        density: 0.0016,
        label: 'fruit',
        render: {
        sprite: {
            texture: tex.toDataURL(),
            xScale: 1,
            yScale: 1
        }
        }
    };

    // Different shapes for variety (still round-ish)
    const opts = { ...baseOpts, ...options };

    let b;
    if (!def.sides || def.sides < 5) {
        b = Bodies.circle(x, y, def.r, opts);
    } else {
        b = Bodies.polygon(x, y, def.sides, def.r, {
        ...opts,
        chamfer: { radius: Math.max(4, def.r * 0.35) }
        });
    }

    // store fruit info
    b.plugin = b.plugin || {};
    b.plugin.fruitIndex = index;
    b.plugin.spawnedAt = now;
    b.plugin.r = def.r;
    b.plugin.name = def.name;

    return b;
    }


  function clampXForIndex(x, idx) {
    const r = FRUITS[idx].r;
    return Math.max(boxLeft + r + 8, Math.min(boxRight - r - 8, x));
  }

  function spawnHeldFruit(x) {
  const idx = nextFruitIndex();
  const clampX = clampXForIndex(x, idx);
  const y = boxTop - 28;

  heldFruit = fruitBody(idx, clampX, y, {
    collisionFilter: { group: -1 },
    render: { opacity: 0.98 }
  });

  Body.setStatic(heldFruit, true); // <-- important
  World.add(engine.world, heldFruit);
}


  function dropHeldFruit() {
    if (!heldFruit) return;
    ensureAudio();
    sfxDrop();

    Body.setStatic(heldFruit, false);
    heldFruit.collisionFilter.group = 0;
    Body.setVelocity(heldFruit, { x: 0, y: 0.6 });

    heldFruit = null;
    consumeNextFruit();
  }

  function resetGame() {
    Composite.clear(engine.world, false);
    mergeLock.clear();
    pops.length = 0;
    setScore(0);
    initQueue();
    rebuildWalls();
    heldFruit = null;
    isDragging = false;
    pointerId = null;
    lastMergeAt = 0;
  }

  // ---------- Merge logic ----------
  function canMerge(a, b) {
    if (!a || !b) return false;
    if (a.label !== 'fruit' || b.label !== 'fruit') return false;
    const ia = a.plugin?.fruitIndex;
    const ib = b.plugin?.fruitIndex;
    if (ia == null || ib == null) return false;
    if (ia !== ib) return false;
    if (ia >= FRUITS.length - 1) return false;

    // avoid merging immediately on spawn
    const now = performance.now();
    if (now - (a.plugin.spawnedAt || 0) < 110) return false;
    if (now - (b.plugin.spawnedAt || 0) < 110) return false;

    // don't merge if either is currently static-held
    if (a.isStatic || b.isStatic) return false;

    return true;
  }

  function pairKey(a, b) {
    const id1 = Math.min(a.id, b.id);
    const id2 = Math.max(a.id, b.id);
    return id1 + ':' + id2;
  }

  Events.on(engine, 'collisionStart', (ev) => {
    const now = performance.now();
    if (now - lastMergeAt < MERGE_COOLDOWN_MS) return;

    for (const p of ev.pairs) {
      const a = p.bodyA, b = p.bodyB;
      if (!canMerge(a, b)) continue;

      const key = pairKey(a, b);
      if (mergeLock.has(key)) continue;
      mergeLock.add(key);

      const ia = a.plugin.fruitIndex;
      const next = ia + 1;

      const pos = {
        x: (a.position.x + b.position.x) / 2,
        y: (a.position.y + b.position.y) / 2
      };

      World.remove(engine.world, a);
      World.remove(engine.world, b);

      const merged = fruitBody(next, pos.x, pos.y);
      World.add(engine.world, merged);

      setScore(score + (next + 1) * 10);
      lastMergeAt = now;

      // pop animation + sfx
      addPop(pos.x, pos.y, FRUITS[next].r);
      ensureAudio();
      sfxMerge();

      // cleanup
      if (mergeLock.size > 1200) mergeLock.clear();

      break;
    }
  });

  // ---------- Overflow / lose condition ----------
  let overflowFrames = 0;
  function fruitRadius(body) {
    return body?.plugin?.r ?? body.circleRadius ?? 0;
  }

  Events.on(engine, 'afterUpdate', () => {
    const bodies = Composite.allBodies(engine.world);
    let overflowing = false;

    for (const b of bodies) {
      if (b.label === 'fruit' && b !== heldFruit && !b.isStatic) {
        const r = fruitRadius(b);
        if (b.position.y - r < boxTop - 6) { overflowing = true; break; }
      }
    }

    if (overflowing) overflowFrames++;
    else overflowFrames = Math.max(0, overflowFrames - 2);

    if (overflowFrames > 45) resetGame();
  });

  // ---------- Drag & drop controls ----------
  function getPointerX(e) {
    const rect = canvas.getBoundingClientRect();
    return (e.clientX - rect.left);
  }

  function onPointerDown(e) {
    if (pointerId != null) return;
    pointerId = e.pointerId;
    canvas.setPointerCapture(pointerId);

    isDragging = true;
    ensureAudio(); // unlock on first gesture

    const x = getPointerX(e);
    if (!heldFruit) spawnHeldFruit(x);
    else Body.setPosition(heldFruit, { x: clampXForIndex(x, nextFruitIndex()), y: heldFruit.position.y });
  }

  function onPointerMove(e) {
    if (!isDragging) return;
    if (e.pointerId !== pointerId) return;

    const x = getPointerX(e);
    if (!heldFruit) spawnHeldFruit(x);

    const idx = nextFruitIndex();
    Body.setPosition(heldFruit, { x: clampXForIndex(x, idx), y: boxTop - 28 });
  }

  function onPointerUp(e) {
    if (e.pointerId !== pointerId) return;
    isDragging = false;
    pointerId = null;
    dropHeldFruit();
  }

  canvas.addEventListener('pointerdown', onPointerDown, { passive:false });
  canvas.addEventListener('pointermove', onPointerMove, { passive:false });
  canvas.addEventListener('pointerup', onPointerUp, { passive:false });
  canvas.addEventListener('pointercancel', onPointerUp, { passive:false });

  // Tap without dragging: drop at tap x
  canvas.addEventListener('click', (e) => {
    if (isDragging) return;
    ensureAudio();
    const x = getPointerX(e);
    if (!heldFruit) spawnHeldFruit(x);
    dropHeldFruit();
  }, { passive:true });

  restartBtn.addEventListener('click', () => resetGame());

  // ---------- Trajectory preview + pop animation render ----------
  function dashedLine(ctx, x1,y1,x2,y2, dash=8, gap=6) {
    const dx = x2-x1, dy = y2-y1;
    const len = Math.hypot(dx,dy) || 1;
    const ux = dx/len, uy = dy/len;
    let t = 0;
    ctx.beginPath();
    while (t < len) {
      const a = t;
      const b = Math.min(len, t + dash);
      ctx.moveTo(x1 + ux*a, y1 + uy*a);
      ctx.lineTo(x1 + ux*b, y1 + uy*b);
      t += dash + gap;
    }
    ctx.stroke();
  }

  function getLandingY(x, r) {
    // Ray-cast down from above the box to the bottom; pick closest hit.
    const start = { x, y: boxTop - 40 };
    const end   = { x, y: boxBottom };
    const bodies = Composite.allBodies(engine.world).filter(b => b !== heldFruit && !b.isSensor);

    const hits = Query.ray(bodies, start, end, 1);
    let bestY = boxBottom - r - 2;

    if (hits && hits.length) {
      // hits are sorted by collision depth-ish; find minimal point.y
      let minY = Infinity;
      for (const h of hits) {
        if (h.point && h.point.y < minY) minY = h.point.y;
      }
      if (isFinite(minY)) bestY = Math.max(boxTop, minY - r - 2);
    }
    return bestY;
  }

  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    const dpr = window.devicePixelRatio || 1;

    // Nice box outline
    ctx.save();
    ctx.lineWidth = 2 * dpr;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.roundRect(boxLeft, boxTop, boxRight - boxLeft, boxBottom - boxTop, 18);
    ctx.stroke();
    ctx.restore();

    // Trajectory line when holding/dragging
    if (heldFruit) {
      const r = fruitRadius(heldFruit);
      const x = heldFruit.position.x;
      const y1 = heldFruit.position.y + r * 0.9;
      const y2 = getLandingY(x, r);

      ctx.save();
      ctx.lineWidth = 2 * dpr;
      ctx.strokeStyle = 'rgba(233,236,255,0.45)';
      dashedLine(ctx, x, y1, x, y2, 10, 8);

      // landing marker
      ctx.fillStyle = 'rgba(233,236,255,0.35)';
      ctx.beginPath();
      ctx.arc(x, y2, Math.max(5, r*0.18), 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // Pop animations (rings + sparkles)
    const now = performance.now();
    for (let i = pops.length - 1; i >= 0; i--) {
      const p = pops[i];
      const age = (now - p.t0) / 1000;
      const life = 0.45;
      if (age > life) { pops.splice(i, 1); continue; }

      const t = age / life;
      const alpha = (1 - t);
      const ringR = p.size * (0.35 + t * 0.85);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 3 * dpr;
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, ringR, 0, Math.PI*2);
      ctx.stroke();

      // sparkles
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      for (let k = 0; k < 6; k++) {
        const ang = (k/6) * Math.PI*2 + t*2.6;
        const rr = ringR * 0.85;
        const sx = p.x + Math.cos(ang) * rr;
        const sy = p.y + Math.sin(ang) * rr;
        ctx.beginPath();
        ctx.arc(sx, sy, Math.max(1.5*dpr, p.size*0.03), 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }
  });

  // ---------- Start ----------
  ensureTextures();
  resize();
  initQueue();
  rebuildWalls();
  setScore(0);

  Render.run(render);
  Runner.run(runner, engine);

})();
</script>
</body>
</html>
